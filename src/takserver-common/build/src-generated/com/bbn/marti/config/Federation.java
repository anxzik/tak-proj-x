//
// This file was generated by the Eclipse Implementation of JAXB, v4.0.3 
// See https://eclipse-ee4j.github.io/jaxb-ri 
// Any modifications to this file will be lost upon recompilation of the source schema. 
//


package com.bbn.marti.config;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import jakarta.xml.bind.annotation.XmlAccessType;
import jakarta.xml.bind.annotation.XmlAccessorType;
import jakarta.xml.bind.annotation.XmlAttribute;
import jakarta.xml.bind.annotation.XmlElement;
import jakarta.xml.bind.annotation.XmlRootElement;
import jakarta.xml.bind.annotation.XmlType;


/**
 * <p>Java class for anonymous complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>{@code
 * <complexType>
 *   <complexContent>
 *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       <sequence>
 *         <element name="federation-server" minOccurs="0">
 *           <complexType>
 *             <complexContent>
 *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 <sequence>
 *                   <element ref="{http://bbn.com/marti/xml/config}tls"/>
 *                   <element name="federation-port" maxOccurs="unbounded" minOccurs="0">
 *                     <complexType>
 *                       <complexContent>
 *                         <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                           <attribute name="port" type="{http://www.w3.org/2001/XMLSchema}int" />
 *                           <attribute name="tlsVersion" type="{http://www.w3.org/2001/XMLSchema}string" default="TLSv1.2" />
 *                         </restriction>
 *                       </complexContent>
 *                     </complexType>
 *                   </element>
 *                   <element name="v1Tls" maxOccurs="unbounded" minOccurs="0">
 *                     <complexType>
 *                       <complexContent>
 *                         <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                           <attribute name="tlsVersion" type="{http://www.w3.org/2001/XMLSchema}string" default="TLSv1.2" />
 *                         </restriction>
 *                       </complexContent>
 *                     </complexType>
 *                   </element>
 *                 </sequence>
 *                 <attribute name="port" type="{http://www.w3.org/2001/XMLSchema}int" default="9000" />
 *                 <attribute name="coreVersion" type="{http://www.w3.org/2001/XMLSchema}int" default="2" />
 *                 <attribute name="v1enabled" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" />
 *                 <attribute name="v2port" type="{http://www.w3.org/2001/XMLSchema}int" default="9001" />
 *                 <attribute name="v2enabled" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" />
 *                 <attribute name="webBaseUrl" type="{http://www.w3.org/2001/XMLSchema}string" default="" />
 *                 <attribute name="httpsPort" type="{http://www.w3.org/2001/XMLSchema}int" default="8444" />
 *                 <attribute name="healthCheckIntervalSeconds" type="{http://www.w3.org/2001/XMLSchema}int" default="3" />
 *                 <attribute name="initializationDelaySeconds" type="{http://www.w3.org/2001/XMLSchema}int" default="30" />
 *                 <attribute name="maxMessageSizeBytes" type="{http://www.w3.org/2001/XMLSchema}int" default="268435456" />
 *               </restriction>
 *             </complexContent>
 *           </complexType>
 *         </element>
 *         <element name="federation-outgoing" maxOccurs="unbounded" minOccurs="0">
 *           <complexType>
 *             <complexContent>
 *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 <attribute name="displayName" type="{http://www.w3.org/2001/XMLSchema}string" />
 *                 <attribute name="address" type="{http://www.w3.org/2001/XMLSchema}string" />
 *                 <attribute name="port" type="{http://www.w3.org/2001/XMLSchema}int" />
 *                 <attribute name="enabled" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" />
 *                 <attribute name="protocolVersion" type="{http://www.w3.org/2001/XMLSchema}int" default="1" />
 *                 <attribute name="reconnectInterval" type="{http://www.w3.org/2001/XMLSchema}int" default="30" />
 *                 <attribute name="filter" type="{http://www.w3.org/2001/XMLSchema}string" />
 *                 <attribute name="maxFrameSize" type="{http://www.w3.org/2001/XMLSchema}int" default="268435456" />
 *                 <attribute name="fallback" type="{http://www.w3.org/2001/XMLSchema}string" />
 *                 <attribute name="maxRetries" type="{http://www.w3.org/2001/XMLSchema}int" default="0" />
 *                 <attribute name="unlimitedRetries" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" />
 *                 <attribute name="connectionToken" type="{http://www.w3.org/2001/XMLSchema}string" default="" />
 *               </restriction>
 *             </complexContent>
 *           </complexType>
 *         </element>
 *         <element name="mission-disruption-tolerance" minOccurs="0">
 *           <complexType>
 *             <complexContent>
 *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 <sequence>
 *                   <element name="mission" maxOccurs="unbounded" minOccurs="0">
 *                     <complexType>
 *                       <complexContent>
 *                         <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                           <attribute name="name" type="{http://www.w3.org/2001/XMLSchema}string" />
 *                           <attribute name="recencySeconds" type="{http://www.w3.org/2001/XMLSchema}long" default="43200" />
 *                         </restriction>
 *                       </complexContent>
 *                     </complexType>
 *                   </element>
 *                 </sequence>
 *               </restriction>
 *             </complexContent>
 *           </complexType>
 *         </element>
 *         <sequence>
 *           <element name="federate" maxOccurs="unbounded" minOccurs="0">
 *             <complexType>
 *               <complexContent>
 *                 <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                   <sequence>
 *                     <element name="inboundGroupMapping" type="{http://www.w3.org/2001/XMLSchema}string" maxOccurs="unbounded" minOccurs="0"/>
 *                     <element name="inboundGroup" type="{http://www.w3.org/2001/XMLSchema}string" maxOccurs="unbounded" minOccurs="0"/>
 *                     <element name="outboundGroup" type="{http://www.w3.org/2001/XMLSchema}string" maxOccurs="unbounded" minOccurs="0"/>
 *                     <element name="missionFederateDefault" type="{http://www.w3.org/2001/XMLSchema}boolean" minOccurs="0"/>
 *                     <element name="mission" maxOccurs="unbounded" minOccurs="0">
 *                       <complexType>
 *                         <complexContent>
 *                           <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                             <attribute name="name" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />
 *                             <attribute name="enabled" use="required" type="{http://www.w3.org/2001/XMLSchema}boolean" />
 *                           </restriction>
 *                         </complexContent>
 *                       </complexType>
 *                     </element>
 *                   </sequence>
 *                   <attribute name="id" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />
 *                   <attribute name="name" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />
 *                   <attribute name="notes" type="{http://www.w3.org/2001/XMLSchema}string" />
 *                   <attribute name="shareAlerts" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" />
 *                   <attribute name="archive" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" />
 *                   <attribute name="federatedGroupMapping" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                   <attribute name="automaticGroupMapping" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                   <attribute name="maxHops" type="{http://www.w3.org/2001/XMLSchema}int" default="-1" />
 *                   <attribute name="fallbackWhenNoGroupMappings" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *                 </restriction>
 *               </complexContent>
 *             </complexType>
 *           </element>
 *         </sequence>
 *         <element name="fileFilter">
 *           <complexType>
 *             <complexContent>
 *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                 <sequence>
 *                   <element name="fileExtension" type="{http://www.w3.org/2001/XMLSchema}string" maxOccurs="unbounded" minOccurs="0"/>
 *                 </sequence>
 *               </restriction>
 *             </complexContent>
 *           </complexType>
 *         </element>
 *         <sequence>
 *           <element name="federateCA" maxOccurs="unbounded" minOccurs="0">
 *             <complexType>
 *               <complexContent>
 *                 <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                   <sequence>
 *                     <element name="inboundGroup" type="{http://www.w3.org/2001/XMLSchema}string" maxOccurs="unbounded" minOccurs="0"/>
 *                     <element name="outboundGroup" type="{http://www.w3.org/2001/XMLSchema}string" maxOccurs="unbounded" minOccurs="0"/>
 *                   </sequence>
 *                   <attribute name="fingerprint" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />
 *                   <attribute name="maxHops" type="{http://www.w3.org/2001/XMLSchema}int" default="-1" />
 *                 </restriction>
 *               </complexContent>
 *             </complexType>
 *           </element>
 *         </sequence>
 *       </sequence>
 *       <attribute name="allowDuplicate" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *       <attribute name="allowFederatedDelete" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *       <attribute name="allowMissionFederation" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" />
 *       <attribute name="allowDataFeedFederation" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" />
 *       <attribute name="enableMissionFederationDisruptionTolerance" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" />
 *       <attribute name="missionFederationDisruptionToleranceRecencySeconds" type="{http://www.w3.org/2001/XMLSchema}long" default="43200" />
 *       <attribute name="federateOnlyPublicMissions" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" />
 *       <attribute name="enableFederation" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *       <attribute name="enableDataPackageAndMissionFileFilter" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
 *     </restriction>
 *   </complexContent>
 * </complexType>
 * }</pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "", propOrder = {
    "federationServer",
    "federationOutgoing",
    "missionDisruptionTolerance",
    "federate",
    "fileFilter",
    "federateCA"
})
@XmlRootElement(name = "federation")
public class Federation
    implements Serializable
{

    private static final long serialVersionUID = 6107951534079953L;
    @XmlElement(name = "federation-server")
    protected Federation.FederationServer federationServer;
    @XmlElement(name = "federation-outgoing")
    protected List<Federation.FederationOutgoing> federationOutgoing;
    @XmlElement(name = "mission-disruption-tolerance")
    protected Federation.MissionDisruptionTolerance missionDisruptionTolerance;
    protected List<Federation.Federate> federate;
    @XmlElement(required = true)
    protected Federation.FileFilter fileFilter;
    protected List<Federation.FederateCA> federateCA;
    @XmlAttribute(name = "allowDuplicate")
    protected Boolean allowDuplicate;
    @XmlAttribute(name = "allowFederatedDelete")
    protected Boolean allowFederatedDelete;
    @XmlAttribute(name = "allowMissionFederation")
    protected Boolean allowMissionFederation;
    @XmlAttribute(name = "allowDataFeedFederation")
    protected Boolean allowDataFeedFederation;
    @XmlAttribute(name = "enableMissionFederationDisruptionTolerance")
    protected Boolean enableMissionFederationDisruptionTolerance;
    @XmlAttribute(name = "missionFederationDisruptionToleranceRecencySeconds")
    protected Long missionFederationDisruptionToleranceRecencySeconds;
    @XmlAttribute(name = "federateOnlyPublicMissions")
    protected Boolean federateOnlyPublicMissions;
    @XmlAttribute(name = "enableFederation")
    protected Boolean enableFederation;
    @XmlAttribute(name = "enableDataPackageAndMissionFileFilter")
    protected Boolean enableDataPackageAndMissionFileFilter;

    /**
     * Gets the value of the federationServer property.
     * 
     * @return
     *     possible object is
     *     {@link Federation.FederationServer }
     *     
     */
    public Federation.FederationServer getFederationServer() {
        return federationServer;
    }

    /**
     * Sets the value of the federationServer property.
     * 
     * @param value
     *     allowed object is
     *     {@link Federation.FederationServer }
     *     
     */
    public void setFederationServer(Federation.FederationServer value) {
        this.federationServer = value;
    }

    /**
     * Gets the value of the federationOutgoing property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a {@code set} method for the federationOutgoing property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFederationOutgoing().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Federation.FederationOutgoing }
     * 
     * 
     * @return
     *     The value of the federationOutgoing property.
     */
    public List<Federation.FederationOutgoing> getFederationOutgoing() {
        if (federationOutgoing == null) {
            federationOutgoing = new ArrayList<>();
        }
        return this.federationOutgoing;
    }

    /**
     * Gets the value of the missionDisruptionTolerance property.
     * 
     * @return
     *     possible object is
     *     {@link Federation.MissionDisruptionTolerance }
     *     
     */
    public Federation.MissionDisruptionTolerance getMissionDisruptionTolerance() {
        return missionDisruptionTolerance;
    }

    /**
     * Sets the value of the missionDisruptionTolerance property.
     * 
     * @param value
     *     allowed object is
     *     {@link Federation.MissionDisruptionTolerance }
     *     
     */
    public void setMissionDisruptionTolerance(Federation.MissionDisruptionTolerance value) {
        this.missionDisruptionTolerance = value;
    }

    /**
     * Gets the value of the federate property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a {@code set} method for the federate property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFederate().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Federation.Federate }
     * 
     * 
     * @return
     *     The value of the federate property.
     */
    public List<Federation.Federate> getFederate() {
        if (federate == null) {
            federate = new ArrayList<>();
        }
        return this.federate;
    }

    /**
     * Gets the value of the fileFilter property.
     * 
     * @return
     *     possible object is
     *     {@link Federation.FileFilter }
     *     
     */
    public Federation.FileFilter getFileFilter() {
        return fileFilter;
    }

    /**
     * Sets the value of the fileFilter property.
     * 
     * @param value
     *     allowed object is
     *     {@link Federation.FileFilter }
     *     
     */
    public void setFileFilter(Federation.FileFilter value) {
        this.fileFilter = value;
    }

    /**
     * Gets the value of the federateCA property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the Jakarta XML Binding object.
     * This is why there is not a {@code set} method for the federateCA property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFederateCA().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link Federation.FederateCA }
     * 
     * 
     * @return
     *     The value of the federateCA property.
     */
    public List<Federation.FederateCA> getFederateCA() {
        if (federateCA == null) {
            federateCA = new ArrayList<>();
        }
        return this.federateCA;
    }

    /**
     * Gets the value of the allowDuplicate property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public boolean isAllowDuplicate() {
        if (allowDuplicate == null) {
            return false;
        } else {
            return allowDuplicate;
        }
    }

    /**
     * Sets the value of the allowDuplicate property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setAllowDuplicate(Boolean value) {
        this.allowDuplicate = value;
    }

    /**
     * Gets the value of the allowFederatedDelete property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public boolean isAllowFederatedDelete() {
        if (allowFederatedDelete == null) {
            return false;
        } else {
            return allowFederatedDelete;
        }
    }

    /**
     * Sets the value of the allowFederatedDelete property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setAllowFederatedDelete(Boolean value) {
        this.allowFederatedDelete = value;
    }

    /**
     * Gets the value of the allowMissionFederation property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public boolean isAllowMissionFederation() {
        if (allowMissionFederation == null) {
            return true;
        } else {
            return allowMissionFederation;
        }
    }

    /**
     * Sets the value of the allowMissionFederation property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setAllowMissionFederation(Boolean value) {
        this.allowMissionFederation = value;
    }

    /**
     * Gets the value of the allowDataFeedFederation property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public boolean isAllowDataFeedFederation() {
        if (allowDataFeedFederation == null) {
            return true;
        } else {
            return allowDataFeedFederation;
        }
    }

    /**
     * Sets the value of the allowDataFeedFederation property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setAllowDataFeedFederation(Boolean value) {
        this.allowDataFeedFederation = value;
    }

    /**
     * Gets the value of the enableMissionFederationDisruptionTolerance property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public boolean isEnableMissionFederationDisruptionTolerance() {
        if (enableMissionFederationDisruptionTolerance == null) {
            return true;
        } else {
            return enableMissionFederationDisruptionTolerance;
        }
    }

    /**
     * Sets the value of the enableMissionFederationDisruptionTolerance property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setEnableMissionFederationDisruptionTolerance(Boolean value) {
        this.enableMissionFederationDisruptionTolerance = value;
    }

    /**
     * Gets the value of the missionFederationDisruptionToleranceRecencySeconds property.
     * 
     * @return
     *     possible object is
     *     {@link Long }
     *     
     */
    public long getMissionFederationDisruptionToleranceRecencySeconds() {
        if (missionFederationDisruptionToleranceRecencySeconds == null) {
            return  43200L;
        } else {
            return missionFederationDisruptionToleranceRecencySeconds;
        }
    }

    /**
     * Sets the value of the missionFederationDisruptionToleranceRecencySeconds property.
     * 
     * @param value
     *     allowed object is
     *     {@link Long }
     *     
     */
    public void setMissionFederationDisruptionToleranceRecencySeconds(Long value) {
        this.missionFederationDisruptionToleranceRecencySeconds = value;
    }

    /**
     * Gets the value of the federateOnlyPublicMissions property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public boolean isFederateOnlyPublicMissions() {
        if (federateOnlyPublicMissions == null) {
            return true;
        } else {
            return federateOnlyPublicMissions;
        }
    }

    /**
     * Sets the value of the federateOnlyPublicMissions property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setFederateOnlyPublicMissions(Boolean value) {
        this.federateOnlyPublicMissions = value;
    }

    /**
     * Gets the value of the enableFederation property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public boolean isEnableFederation() {
        if (enableFederation == null) {
            return false;
        } else {
            return enableFederation;
        }
    }

    /**
     * Sets the value of the enableFederation property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setEnableFederation(Boolean value) {
        this.enableFederation = value;
    }

    /**
     * Gets the value of the enableDataPackageAndMissionFileFilter property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public boolean isEnableDataPackageAndMissionFileFilter() {
        if (enableDataPackageAndMissionFileFilter == null) {
            return false;
        } else {
            return enableDataPackageAndMissionFileFilter;
        }
    }

    /**
     * Sets the value of the enableDataPackageAndMissionFileFilter property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setEnableDataPackageAndMissionFileFilter(Boolean value) {
        this.enableDataPackageAndMissionFileFilter = value;
    }


    /**
     * Federate
     * 
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       <sequence>
     *         <element name="inboundGroupMapping" type="{http://www.w3.org/2001/XMLSchema}string" maxOccurs="unbounded" minOccurs="0"/>
     *         <element name="inboundGroup" type="{http://www.w3.org/2001/XMLSchema}string" maxOccurs="unbounded" minOccurs="0"/>
     *         <element name="outboundGroup" type="{http://www.w3.org/2001/XMLSchema}string" maxOccurs="unbounded" minOccurs="0"/>
     *         <element name="missionFederateDefault" type="{http://www.w3.org/2001/XMLSchema}boolean" minOccurs="0"/>
     *         <element name="mission" maxOccurs="unbounded" minOccurs="0">
     *           <complexType>
     *             <complexContent>
     *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *                 <attribute name="name" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />
     *                 <attribute name="enabled" use="required" type="{http://www.w3.org/2001/XMLSchema}boolean" />
     *               </restriction>
     *             </complexContent>
     *           </complexType>
     *         </element>
     *       </sequence>
     *       <attribute name="id" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />
     *       <attribute name="name" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />
     *       <attribute name="notes" type="{http://www.w3.org/2001/XMLSchema}string" />
     *       <attribute name="shareAlerts" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" />
     *       <attribute name="archive" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" />
     *       <attribute name="federatedGroupMapping" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       <attribute name="automaticGroupMapping" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *       <attribute name="maxHops" type="{http://www.w3.org/2001/XMLSchema}int" default="-1" />
     *       <attribute name="fallbackWhenNoGroupMappings" type="{http://www.w3.org/2001/XMLSchema}boolean" default="false" />
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "inboundGroupMapping",
        "inboundGroup",
        "outboundGroup",
        "missionFederateDefault",
        "mission"
    })
    public static class Federate
        implements Serializable
    {

        private static final long serialVersionUID = 6107951534079953L;
        protected List<String> inboundGroupMapping;
        protected List<String> inboundGroup;
        protected List<String> outboundGroup;
        @XmlElement(defaultValue = "true")
        protected Boolean missionFederateDefault;
        protected List<Federation.Federate.Mission> mission;
        @XmlAttribute(name = "id", required = true)
        protected String id;
        @XmlAttribute(name = "name", required = true)
        protected String name;
        @XmlAttribute(name = "notes")
        protected String notes;
        @XmlAttribute(name = "shareAlerts")
        protected Boolean shareAlerts;
        @XmlAttribute(name = "archive")
        protected Boolean archive;
        @XmlAttribute(name = "federatedGroupMapping")
        protected Boolean federatedGroupMapping;
        @XmlAttribute(name = "automaticGroupMapping")
        protected Boolean automaticGroupMapping;
        @XmlAttribute(name = "maxHops")
        protected Integer maxHops;
        @XmlAttribute(name = "fallbackWhenNoGroupMappings")
        protected Boolean fallbackWhenNoGroupMappings;

        /**
         * Gets the value of the inboundGroupMapping property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the Jakarta XML Binding object.
         * This is why there is not a {@code set} method for the inboundGroupMapping property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getInboundGroupMapping().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         * @return
         *     The value of the inboundGroupMapping property.
         */
        public List<String> getInboundGroupMapping() {
            if (inboundGroupMapping == null) {
                inboundGroupMapping = new ArrayList<>();
            }
            return this.inboundGroupMapping;
        }

        /**
         * Gets the value of the inboundGroup property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the Jakarta XML Binding object.
         * This is why there is not a {@code set} method for the inboundGroup property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getInboundGroup().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         * @return
         *     The value of the inboundGroup property.
         */
        public List<String> getInboundGroup() {
            if (inboundGroup == null) {
                inboundGroup = new ArrayList<>();
            }
            return this.inboundGroup;
        }

        /**
         * Gets the value of the outboundGroup property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the Jakarta XML Binding object.
         * This is why there is not a {@code set} method for the outboundGroup property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getOutboundGroup().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         * @return
         *     The value of the outboundGroup property.
         */
        public List<String> getOutboundGroup() {
            if (outboundGroup == null) {
                outboundGroup = new ArrayList<>();
            }
            return this.outboundGroup;
        }

        /**
         * Gets the value of the missionFederateDefault property.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public Boolean isMissionFederateDefault() {
            return missionFederateDefault;
        }

        /**
         * Sets the value of the missionFederateDefault property.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setMissionFederateDefault(Boolean value) {
            this.missionFederateDefault = value;
        }

        /**
         * Gets the value of the mission property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the Jakarta XML Binding object.
         * This is why there is not a {@code set} method for the mission property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getMission().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Federation.Federate.Mission }
         * 
         * 
         * @return
         *     The value of the mission property.
         */
        public List<Federation.Federate.Mission> getMission() {
            if (mission == null) {
                mission = new ArrayList<>();
            }
            return this.mission;
        }

        /**
         * Gets the value of the id property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getId() {
            return id;
        }

        /**
         * Sets the value of the id property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setId(String value) {
            this.id = value;
        }

        /**
         * Gets the value of the name property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getName() {
            return name;
        }

        /**
         * Sets the value of the name property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setName(String value) {
            this.name = value;
        }

        /**
         * Gets the value of the notes property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getNotes() {
            return notes;
        }

        /**
         * Sets the value of the notes property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setNotes(String value) {
            this.notes = value;
        }

        /**
         * Gets the value of the shareAlerts property.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isShareAlerts() {
            if (shareAlerts == null) {
                return true;
            } else {
                return shareAlerts;
            }
        }

        /**
         * Sets the value of the shareAlerts property.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setShareAlerts(Boolean value) {
            this.shareAlerts = value;
        }

        /**
         * Gets the value of the archive property.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isArchive() {
            if (archive == null) {
                return true;
            } else {
                return archive;
            }
        }

        /**
         * Sets the value of the archive property.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setArchive(Boolean value) {
            this.archive = value;
        }

        /**
         * Gets the value of the federatedGroupMapping property.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isFederatedGroupMapping() {
            if (federatedGroupMapping == null) {
                return false;
            } else {
                return federatedGroupMapping;
            }
        }

        /**
         * Sets the value of the federatedGroupMapping property.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setFederatedGroupMapping(Boolean value) {
            this.federatedGroupMapping = value;
        }

        /**
         * Gets the value of the automaticGroupMapping property.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isAutomaticGroupMapping() {
            if (automaticGroupMapping == null) {
                return false;
            } else {
                return automaticGroupMapping;
            }
        }

        /**
         * Sets the value of the automaticGroupMapping property.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setAutomaticGroupMapping(Boolean value) {
            this.automaticGroupMapping = value;
        }

        /**
         * Gets the value of the maxHops property.
         * 
         * @return
         *     possible object is
         *     {@link Integer }
         *     
         */
        public int getMaxHops() {
            if (maxHops == null) {
                return -1;
            } else {
                return maxHops;
            }
        }

        /**
         * Sets the value of the maxHops property.
         * 
         * @param value
         *     allowed object is
         *     {@link Integer }
         *     
         */
        public void setMaxHops(Integer value) {
            this.maxHops = value;
        }

        /**
         * Gets the value of the fallbackWhenNoGroupMappings property.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isFallbackWhenNoGroupMappings() {
            if (fallbackWhenNoGroupMappings == null) {
                return false;
            } else {
                return fallbackWhenNoGroupMappings;
            }
        }

        /**
         * Sets the value of the fallbackWhenNoGroupMappings property.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setFallbackWhenNoGroupMappings(Boolean value) {
            this.fallbackWhenNoGroupMappings = value;
        }


        /**
         * <p>Java class for anonymous complex type.
         * 
         * <p>The following schema fragment specifies the expected content contained within this class.
         * 
         * <pre>{@code
         * <complexType>
         *   <complexContent>
         *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
         *       <attribute name="name" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />
         *       <attribute name="enabled" use="required" type="{http://www.w3.org/2001/XMLSchema}boolean" />
         *     </restriction>
         *   </complexContent>
         * </complexType>
         * }</pre>
         * 
         * 
         */
        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "")
        public static class Mission
            implements Serializable
        {

            private static final long serialVersionUID = 6107951534079953L;
            @XmlAttribute(name = "name", required = true)
            protected String name;
            @XmlAttribute(name = "enabled", required = true)
            protected boolean enabled;

            /**
             * Gets the value of the name property.
             * 
             * @return
             *     possible object is
             *     {@link String }
             *     
             */
            public String getName() {
                return name;
            }

            /**
             * Sets the value of the name property.
             * 
             * @param value
             *     allowed object is
             *     {@link String }
             *     
             */
            public void setName(String value) {
                this.name = value;
            }

            /**
             * Gets the value of the enabled property.
             * 
             */
            public boolean isEnabled() {
                return enabled;
            }

            /**
             * Sets the value of the enabled property.
             * 
             */
            public void setEnabled(boolean value) {
                this.enabled = value;
            }

        }

    }


    /**
     * Federate-CA
     * 
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       <sequence>
     *         <element name="inboundGroup" type="{http://www.w3.org/2001/XMLSchema}string" maxOccurs="unbounded" minOccurs="0"/>
     *         <element name="outboundGroup" type="{http://www.w3.org/2001/XMLSchema}string" maxOccurs="unbounded" minOccurs="0"/>
     *       </sequence>
     *       <attribute name="fingerprint" use="required" type="{http://www.w3.org/2001/XMLSchema}string" />
     *       <attribute name="maxHops" type="{http://www.w3.org/2001/XMLSchema}int" default="-1" />
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "inboundGroup",
        "outboundGroup"
    })
    public static class FederateCA
        implements Serializable
    {

        private static final long serialVersionUID = 6107951534079953L;
        protected List<String> inboundGroup;
        protected List<String> outboundGroup;
        @XmlAttribute(name = "fingerprint", required = true)
        protected String fingerprint;
        @XmlAttribute(name = "maxHops")
        protected Integer maxHops;

        /**
         * Gets the value of the inboundGroup property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the Jakarta XML Binding object.
         * This is why there is not a {@code set} method for the inboundGroup property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getInboundGroup().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         * @return
         *     The value of the inboundGroup property.
         */
        public List<String> getInboundGroup() {
            if (inboundGroup == null) {
                inboundGroup = new ArrayList<>();
            }
            return this.inboundGroup;
        }

        /**
         * Gets the value of the outboundGroup property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the Jakarta XML Binding object.
         * This is why there is not a {@code set} method for the outboundGroup property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getOutboundGroup().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         * @return
         *     The value of the outboundGroup property.
         */
        public List<String> getOutboundGroup() {
            if (outboundGroup == null) {
                outboundGroup = new ArrayList<>();
            }
            return this.outboundGroup;
        }

        /**
         * Gets the value of the fingerprint property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getFingerprint() {
            return fingerprint;
        }

        /**
         * Sets the value of the fingerprint property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setFingerprint(String value) {
            this.fingerprint = value;
        }

        /**
         * Gets the value of the maxHops property.
         * 
         * @return
         *     possible object is
         *     {@link Integer }
         *     
         */
        public int getMaxHops() {
            if (maxHops == null) {
                return -1;
            } else {
                return maxHops;
            }
        }

        /**
         * Sets the value of the maxHops property.
         * 
         * @param value
         *     allowed object is
         *     {@link Integer }
         *     
         */
        public void setMaxHops(Integer value) {
            this.maxHops = value;
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       <attribute name="displayName" type="{http://www.w3.org/2001/XMLSchema}string" />
     *       <attribute name="address" type="{http://www.w3.org/2001/XMLSchema}string" />
     *       <attribute name="port" type="{http://www.w3.org/2001/XMLSchema}int" />
     *       <attribute name="enabled" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" />
     *       <attribute name="protocolVersion" type="{http://www.w3.org/2001/XMLSchema}int" default="1" />
     *       <attribute name="reconnectInterval" type="{http://www.w3.org/2001/XMLSchema}int" default="30" />
     *       <attribute name="filter" type="{http://www.w3.org/2001/XMLSchema}string" />
     *       <attribute name="maxFrameSize" type="{http://www.w3.org/2001/XMLSchema}int" default="268435456" />
     *       <attribute name="fallback" type="{http://www.w3.org/2001/XMLSchema}string" />
     *       <attribute name="maxRetries" type="{http://www.w3.org/2001/XMLSchema}int" default="0" />
     *       <attribute name="unlimitedRetries" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" />
     *       <attribute name="connectionToken" type="{http://www.w3.org/2001/XMLSchema}string" default="" />
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "")
    public static class FederationOutgoing
        implements Serializable
    {

        private static final long serialVersionUID = 6107951534079953L;
        @XmlAttribute(name = "displayName")
        protected String displayName;
        @XmlAttribute(name = "address")
        protected String address;
        @XmlAttribute(name = "port")
        protected Integer port;
        @XmlAttribute(name = "enabled")
        protected Boolean enabled;
        @XmlAttribute(name = "protocolVersion")
        protected Integer protocolVersion;
        @XmlAttribute(name = "reconnectInterval")
        protected Integer reconnectInterval;
        @XmlAttribute(name = "filter")
        protected String filter;
        @XmlAttribute(name = "maxFrameSize")
        protected Integer maxFrameSize;
        @XmlAttribute(name = "fallback")
        protected String fallback;
        @XmlAttribute(name = "maxRetries")
        protected Integer maxRetries;
        @XmlAttribute(name = "unlimitedRetries")
        protected Boolean unlimitedRetries;
        @XmlAttribute(name = "connectionToken")
        protected String connectionToken;

        /**
         * Gets the value of the displayName property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getDisplayName() {
            return displayName;
        }

        /**
         * Sets the value of the displayName property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setDisplayName(String value) {
            this.displayName = value;
        }

        /**
         * Gets the value of the address property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getAddress() {
            return address;
        }

        /**
         * Sets the value of the address property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setAddress(String value) {
            this.address = value;
        }

        /**
         * Gets the value of the port property.
         * 
         * @return
         *     possible object is
         *     {@link Integer }
         *     
         */
        public Integer getPort() {
            return port;
        }

        /**
         * Sets the value of the port property.
         * 
         * @param value
         *     allowed object is
         *     {@link Integer }
         *     
         */
        public void setPort(Integer value) {
            this.port = value;
        }

        /**
         * Gets the value of the enabled property.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isEnabled() {
            if (enabled == null) {
                return true;
            } else {
                return enabled;
            }
        }

        /**
         * Sets the value of the enabled property.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setEnabled(Boolean value) {
            this.enabled = value;
        }

        /**
         * Gets the value of the protocolVersion property.
         * 
         * @return
         *     possible object is
         *     {@link Integer }
         *     
         */
        public int getProtocolVersion() {
            if (protocolVersion == null) {
                return  1;
            } else {
                return protocolVersion;
            }
        }

        /**
         * Sets the value of the protocolVersion property.
         * 
         * @param value
         *     allowed object is
         *     {@link Integer }
         *     
         */
        public void setProtocolVersion(Integer value) {
            this.protocolVersion = value;
        }

        /**
         * Gets the value of the reconnectInterval property.
         * 
         * @return
         *     possible object is
         *     {@link Integer }
         *     
         */
        public int getReconnectInterval() {
            if (reconnectInterval == null) {
                return  30;
            } else {
                return reconnectInterval;
            }
        }

        /**
         * Sets the value of the reconnectInterval property.
         * 
         * @param value
         *     allowed object is
         *     {@link Integer }
         *     
         */
        public void setReconnectInterval(Integer value) {
            this.reconnectInterval = value;
        }

        /**
         * Gets the value of the filter property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getFilter() {
            return filter;
        }

        /**
         * Sets the value of the filter property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setFilter(String value) {
            this.filter = value;
        }

        /**
         * Gets the value of the maxFrameSize property.
         * 
         * @return
         *     possible object is
         *     {@link Integer }
         *     
         */
        public int getMaxFrameSize() {
            if (maxFrameSize == null) {
                return  268435456;
            } else {
                return maxFrameSize;
            }
        }

        /**
         * Sets the value of the maxFrameSize property.
         * 
         * @param value
         *     allowed object is
         *     {@link Integer }
         *     
         */
        public void setMaxFrameSize(Integer value) {
            this.maxFrameSize = value;
        }

        /**
         * Gets the value of the fallback property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getFallback() {
            return fallback;
        }

        /**
         * Sets the value of the fallback property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setFallback(String value) {
            this.fallback = value;
        }

        /**
         * Gets the value of the maxRetries property.
         * 
         * @return
         *     possible object is
         *     {@link Integer }
         *     
         */
        public int getMaxRetries() {
            if (maxRetries == null) {
                return  0;
            } else {
                return maxRetries;
            }
        }

        /**
         * Sets the value of the maxRetries property.
         * 
         * @param value
         *     allowed object is
         *     {@link Integer }
         *     
         */
        public void setMaxRetries(Integer value) {
            this.maxRetries = value;
        }

        /**
         * Gets the value of the unlimitedRetries property.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isUnlimitedRetries() {
            if (unlimitedRetries == null) {
                return true;
            } else {
                return unlimitedRetries;
            }
        }

        /**
         * Sets the value of the unlimitedRetries property.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setUnlimitedRetries(Boolean value) {
            this.unlimitedRetries = value;
        }

        /**
         * Gets the value of the connectionToken property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getConnectionToken() {
            if (connectionToken == null) {
                return "";
            } else {
                return connectionToken;
            }
        }

        /**
         * Sets the value of the connectionToken property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setConnectionToken(String value) {
            this.connectionToken = value;
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       <sequence>
     *         <element ref="{http://bbn.com/marti/xml/config}tls"/>
     *         <element name="federation-port" maxOccurs="unbounded" minOccurs="0">
     *           <complexType>
     *             <complexContent>
     *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *                 <attribute name="port" type="{http://www.w3.org/2001/XMLSchema}int" />
     *                 <attribute name="tlsVersion" type="{http://www.w3.org/2001/XMLSchema}string" default="TLSv1.2" />
     *               </restriction>
     *             </complexContent>
     *           </complexType>
     *         </element>
     *         <element name="v1Tls" maxOccurs="unbounded" minOccurs="0">
     *           <complexType>
     *             <complexContent>
     *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *                 <attribute name="tlsVersion" type="{http://www.w3.org/2001/XMLSchema}string" default="TLSv1.2" />
     *               </restriction>
     *             </complexContent>
     *           </complexType>
     *         </element>
     *       </sequence>
     *       <attribute name="port" type="{http://www.w3.org/2001/XMLSchema}int" default="9000" />
     *       <attribute name="coreVersion" type="{http://www.w3.org/2001/XMLSchema}int" default="2" />
     *       <attribute name="v1enabled" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" />
     *       <attribute name="v2port" type="{http://www.w3.org/2001/XMLSchema}int" default="9001" />
     *       <attribute name="v2enabled" type="{http://www.w3.org/2001/XMLSchema}boolean" default="true" />
     *       <attribute name="webBaseUrl" type="{http://www.w3.org/2001/XMLSchema}string" default="" />
     *       <attribute name="httpsPort" type="{http://www.w3.org/2001/XMLSchema}int" default="8444" />
     *       <attribute name="healthCheckIntervalSeconds" type="{http://www.w3.org/2001/XMLSchema}int" default="3" />
     *       <attribute name="initializationDelaySeconds" type="{http://www.w3.org/2001/XMLSchema}int" default="30" />
     *       <attribute name="maxMessageSizeBytes" type="{http://www.w3.org/2001/XMLSchema}int" default="268435456" />
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "tls",
        "federationPort",
        "v1Tls"
    })
    public static class FederationServer
        implements Serializable
    {

        private static final long serialVersionUID = 6107951534079953L;
        @XmlElement(required = true)
        protected Tls tls;
        @XmlElement(name = "federation-port")
        protected List<Federation.FederationServer.FederationPort> federationPort;
        protected List<Federation.FederationServer.V1Tls> v1Tls;
        @XmlAttribute(name = "port")
        protected Integer port;
        @XmlAttribute(name = "coreVersion")
        protected Integer coreVersion;
        @XmlAttribute(name = "v1enabled")
        protected Boolean v1Enabled;
        @XmlAttribute(name = "v2port")
        protected Integer v2Port;
        @XmlAttribute(name = "v2enabled")
        protected Boolean v2Enabled;
        @XmlAttribute(name = "webBaseUrl")
        protected String webBaseUrl;
        @XmlAttribute(name = "httpsPort")
        protected Integer httpsPort;
        @XmlAttribute(name = "healthCheckIntervalSeconds")
        protected Integer healthCheckIntervalSeconds;
        @XmlAttribute(name = "initializationDelaySeconds")
        protected Integer initializationDelaySeconds;
        @XmlAttribute(name = "maxMessageSizeBytes")
        protected Integer maxMessageSizeBytes;

        /**
         * Gets the value of the tls property.
         * 
         * @return
         *     possible object is
         *     {@link Tls }
         *     
         */
        public Tls getTls() {
            return tls;
        }

        /**
         * Sets the value of the tls property.
         * 
         * @param value
         *     allowed object is
         *     {@link Tls }
         *     
         */
        public void setTls(Tls value) {
            this.tls = value;
        }

        /**
         * Gets the value of the federationPort property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the Jakarta XML Binding object.
         * This is why there is not a {@code set} method for the federationPort property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getFederationPort().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Federation.FederationServer.FederationPort }
         * 
         * 
         * @return
         *     The value of the federationPort property.
         */
        public List<Federation.FederationServer.FederationPort> getFederationPort() {
            if (federationPort == null) {
                federationPort = new ArrayList<>();
            }
            return this.federationPort;
        }

        /**
         * Gets the value of the v1Tls property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the Jakarta XML Binding object.
         * This is why there is not a {@code set} method for the v1Tls property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getV1Tls().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Federation.FederationServer.V1Tls }
         * 
         * 
         * @return
         *     The value of the v1Tls property.
         */
        public List<Federation.FederationServer.V1Tls> getV1Tls() {
            if (v1Tls == null) {
                v1Tls = new ArrayList<>();
            }
            return this.v1Tls;
        }

        /**
         * Gets the value of the port property.
         * 
         * @return
         *     possible object is
         *     {@link Integer }
         *     
         */
        public int getPort() {
            if (port == null) {
                return  9000;
            } else {
                return port;
            }
        }

        /**
         * Sets the value of the port property.
         * 
         * @param value
         *     allowed object is
         *     {@link Integer }
         *     
         */
        public void setPort(Integer value) {
            this.port = value;
        }

        /**
         * Gets the value of the coreVersion property.
         * 
         * @return
         *     possible object is
         *     {@link Integer }
         *     
         */
        public int getCoreVersion() {
            if (coreVersion == null) {
                return  2;
            } else {
                return coreVersion;
            }
        }

        /**
         * Sets the value of the coreVersion property.
         * 
         * @param value
         *     allowed object is
         *     {@link Integer }
         *     
         */
        public void setCoreVersion(Integer value) {
            this.coreVersion = value;
        }

        /**
         * Gets the value of the v1Enabled property.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isV1Enabled() {
            if (v1Enabled == null) {
                return true;
            } else {
                return v1Enabled;
            }
        }

        /**
         * Sets the value of the v1Enabled property.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setV1Enabled(Boolean value) {
            this.v1Enabled = value;
        }

        /**
         * Gets the value of the v2Port property.
         * 
         * @return
         *     possible object is
         *     {@link Integer }
         *     
         */
        public int getV2Port() {
            if (v2Port == null) {
                return  9001;
            } else {
                return v2Port;
            }
        }

        /**
         * Sets the value of the v2Port property.
         * 
         * @param value
         *     allowed object is
         *     {@link Integer }
         *     
         */
        public void setV2Port(Integer value) {
            this.v2Port = value;
        }

        /**
         * Gets the value of the v2Enabled property.
         * 
         * @return
         *     possible object is
         *     {@link Boolean }
         *     
         */
        public boolean isV2Enabled() {
            if (v2Enabled == null) {
                return true;
            } else {
                return v2Enabled;
            }
        }

        /**
         * Sets the value of the v2Enabled property.
         * 
         * @param value
         *     allowed object is
         *     {@link Boolean }
         *     
         */
        public void setV2Enabled(Boolean value) {
            this.v2Enabled = value;
        }

        /**
         * Gets the value of the webBaseUrl property.
         * 
         * @return
         *     possible object is
         *     {@link String }
         *     
         */
        public String getWebBaseUrl() {
            if (webBaseUrl == null) {
                return "";
            } else {
                return webBaseUrl;
            }
        }

        /**
         * Sets the value of the webBaseUrl property.
         * 
         * @param value
         *     allowed object is
         *     {@link String }
         *     
         */
        public void setWebBaseUrl(String value) {
            this.webBaseUrl = value;
        }

        /**
         * Gets the value of the httpsPort property.
         * 
         * @return
         *     possible object is
         *     {@link Integer }
         *     
         */
        public int getHttpsPort() {
            if (httpsPort == null) {
                return  8444;
            } else {
                return httpsPort;
            }
        }

        /**
         * Sets the value of the httpsPort property.
         * 
         * @param value
         *     allowed object is
         *     {@link Integer }
         *     
         */
        public void setHttpsPort(Integer value) {
            this.httpsPort = value;
        }

        /**
         * Gets the value of the healthCheckIntervalSeconds property.
         * 
         * @return
         *     possible object is
         *     {@link Integer }
         *     
         */
        public int getHealthCheckIntervalSeconds() {
            if (healthCheckIntervalSeconds == null) {
                return  3;
            } else {
                return healthCheckIntervalSeconds;
            }
        }

        /**
         * Sets the value of the healthCheckIntervalSeconds property.
         * 
         * @param value
         *     allowed object is
         *     {@link Integer }
         *     
         */
        public void setHealthCheckIntervalSeconds(Integer value) {
            this.healthCheckIntervalSeconds = value;
        }

        /**
         * Gets the value of the initializationDelaySeconds property.
         * 
         * @return
         *     possible object is
         *     {@link Integer }
         *     
         */
        public int getInitializationDelaySeconds() {
            if (initializationDelaySeconds == null) {
                return  30;
            } else {
                return initializationDelaySeconds;
            }
        }

        /**
         * Sets the value of the initializationDelaySeconds property.
         * 
         * @param value
         *     allowed object is
         *     {@link Integer }
         *     
         */
        public void setInitializationDelaySeconds(Integer value) {
            this.initializationDelaySeconds = value;
        }

        /**
         * Gets the value of the maxMessageSizeBytes property.
         * 
         * @return
         *     possible object is
         *     {@link Integer }
         *     
         */
        public int getMaxMessageSizeBytes() {
            if (maxMessageSizeBytes == null) {
                return  268435456;
            } else {
                return maxMessageSizeBytes;
            }
        }

        /**
         * Sets the value of the maxMessageSizeBytes property.
         * 
         * @param value
         *     allowed object is
         *     {@link Integer }
         *     
         */
        public void setMaxMessageSizeBytes(Integer value) {
            this.maxMessageSizeBytes = value;
        }


        /**
         * <p>Java class for anonymous complex type.
         * 
         * <p>The following schema fragment specifies the expected content contained within this class.
         * 
         * <pre>{@code
         * <complexType>
         *   <complexContent>
         *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
         *       <attribute name="port" type="{http://www.w3.org/2001/XMLSchema}int" />
         *       <attribute name="tlsVersion" type="{http://www.w3.org/2001/XMLSchema}string" default="TLSv1.2" />
         *     </restriction>
         *   </complexContent>
         * </complexType>
         * }</pre>
         * 
         * 
         */
        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "")
        public static class FederationPort
            implements Serializable
        {

            private static final long serialVersionUID = 6107951534079953L;
            @XmlAttribute(name = "port")
            protected Integer port;
            @XmlAttribute(name = "tlsVersion")
            protected String tlsVersion;

            /**
             * Gets the value of the port property.
             * 
             * @return
             *     possible object is
             *     {@link Integer }
             *     
             */
            public Integer getPort() {
                return port;
            }

            /**
             * Sets the value of the port property.
             * 
             * @param value
             *     allowed object is
             *     {@link Integer }
             *     
             */
            public void setPort(Integer value) {
                this.port = value;
            }

            /**
             * Gets the value of the tlsVersion property.
             * 
             * @return
             *     possible object is
             *     {@link String }
             *     
             */
            public String getTlsVersion() {
                if (tlsVersion == null) {
                    return "TLSv1.2";
                } else {
                    return tlsVersion;
                }
            }

            /**
             * Sets the value of the tlsVersion property.
             * 
             * @param value
             *     allowed object is
             *     {@link String }
             *     
             */
            public void setTlsVersion(String value) {
                this.tlsVersion = value;
            }

        }


        /**
         * <p>Java class for anonymous complex type.
         * 
         * <p>The following schema fragment specifies the expected content contained within this class.
         * 
         * <pre>{@code
         * <complexType>
         *   <complexContent>
         *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
         *       <attribute name="tlsVersion" type="{http://www.w3.org/2001/XMLSchema}string" default="TLSv1.2" />
         *     </restriction>
         *   </complexContent>
         * </complexType>
         * }</pre>
         * 
         * 
         */
        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "")
        public static class V1Tls
            implements Serializable
        {

            private static final long serialVersionUID = 6107951534079953L;
            @XmlAttribute(name = "tlsVersion")
            protected String tlsVersion;

            /**
             * Gets the value of the tlsVersion property.
             * 
             * @return
             *     possible object is
             *     {@link String }
             *     
             */
            public String getTlsVersion() {
                if (tlsVersion == null) {
                    return "TLSv1.2";
                } else {
                    return tlsVersion;
                }
            }

            /**
             * Sets the value of the tlsVersion property.
             * 
             * @param value
             *     allowed object is
             *     {@link String }
             *     
             */
            public void setTlsVersion(String value) {
                this.tlsVersion = value;
            }

        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       <sequence>
     *         <element name="fileExtension" type="{http://www.w3.org/2001/XMLSchema}string" maxOccurs="unbounded" minOccurs="0"/>
     *       </sequence>
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "fileExtension"
    })
    public static class FileFilter
        implements Serializable
    {

        private static final long serialVersionUID = 6107951534079953L;
        protected List<String> fileExtension;

        /**
         * Gets the value of the fileExtension property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the Jakarta XML Binding object.
         * This is why there is not a {@code set} method for the fileExtension property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getFileExtension().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link String }
         * 
         * 
         * @return
         *     The value of the fileExtension property.
         */
        public List<String> getFileExtension() {
            if (fileExtension == null) {
                fileExtension = new ArrayList<>();
            }
            return this.fileExtension;
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>{@code
     * <complexType>
     *   <complexContent>
     *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       <sequence>
     *         <element name="mission" maxOccurs="unbounded" minOccurs="0">
     *           <complexType>
     *             <complexContent>
     *               <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *                 <attribute name="name" type="{http://www.w3.org/2001/XMLSchema}string" />
     *                 <attribute name="recencySeconds" type="{http://www.w3.org/2001/XMLSchema}long" default="43200" />
     *               </restriction>
     *             </complexContent>
     *           </complexType>
     *         </element>
     *       </sequence>
     *     </restriction>
     *   </complexContent>
     * </complexType>
     * }</pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "mission"
    })
    public static class MissionDisruptionTolerance
        implements Serializable
    {

        private static final long serialVersionUID = 6107951534079953L;
        protected List<Federation.MissionDisruptionTolerance.Mission> mission;

        /**
         * Gets the value of the mission property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the Jakarta XML Binding object.
         * This is why there is not a {@code set} method for the mission property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getMission().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Federation.MissionDisruptionTolerance.Mission }
         * 
         * 
         * @return
         *     The value of the mission property.
         */
        public List<Federation.MissionDisruptionTolerance.Mission> getMission() {
            if (mission == null) {
                mission = new ArrayList<>();
            }
            return this.mission;
        }


        /**
         * <p>Java class for anonymous complex type.
         * 
         * <p>The following schema fragment specifies the expected content contained within this class.
         * 
         * <pre>{@code
         * <complexType>
         *   <complexContent>
         *     <restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
         *       <attribute name="name" type="{http://www.w3.org/2001/XMLSchema}string" />
         *       <attribute name="recencySeconds" type="{http://www.w3.org/2001/XMLSchema}long" default="43200" />
         *     </restriction>
         *   </complexContent>
         * </complexType>
         * }</pre>
         * 
         * 
         */
        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "")
        public static class Mission
            implements Serializable
        {

            private static final long serialVersionUID = 6107951534079953L;
            @XmlAttribute(name = "name")
            protected String name;
            @XmlAttribute(name = "recencySeconds")
            protected Long recencySeconds;

            /**
             * Gets the value of the name property.
             * 
             * @return
             *     possible object is
             *     {@link String }
             *     
             */
            public String getName() {
                return name;
            }

            /**
             * Sets the value of the name property.
             * 
             * @param value
             *     allowed object is
             *     {@link String }
             *     
             */
            public void setName(String value) {
                this.name = value;
            }

            /**
             * Gets the value of the recencySeconds property.
             * 
             * @return
             *     possible object is
             *     {@link Long }
             *     
             */
            public long getRecencySeconds() {
                if (recencySeconds == null) {
                    return  43200L;
                } else {
                    return recencySeconds;
                }
            }

            /**
             * Sets the value of the recencySeconds property.
             * 
             * @param value
             *     allowed object is
             *     {@link Long }
             *     
             */
            public void setRecencySeconds(Long value) {
                this.recencySeconds = value;
            }

        }

    }

}
